//getprojects
let table = base.getTable('Projects')
let query = await table.selectRecordsAsync()

let newRecordArray = []
let updateRecArray = []

await getProjects()

async function getProjects() {
    const username = 'test@gmail.org';
    const apiToken = '12345';
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);

    const response = await fetch("https://test.atlassian.net/rest/api/3/project", {
        method: 'GET',
        headers: {
            "Authorization": `Basic ${base64Credentials}`,
            "Accept": "application/json"
        }
    });

    if (!response.ok) {
        console.error("Failed to fetch projects:", response.statusText);
        return;
    }

    
    const payloadData = await response.json();
    console.log(payloadData);
    
    for (let projectData of payloadData) {
        let foundCheck = false;
        for (let rec of query.records) {
            if (rec.getCellValueAsString('Project ID') == projectData['id']) {
                foundCheck = true
                let updateRec = {
                    id: rec.id,
                    fields: {
                        "Project ID": projectData['id'],
                        "Project URL": projectData['self'],
                        //"Project Category": projectData['projectCategory']['name'],
                        "Key": projectData['key'],
                        "Name": projectData['name'],
                        "Project Type": projectData['projectTypeKey']
                    }
                }
                updateRecArray.push(updateRec)
                break;
            }
        }

        if (foundCheck == false) {
            let newRecord = {
                fields: {
                    "Project ID": projectData['id'],
                    "Project URL": projectData['self'],
                    //"Project Category": projectData['projectCategory']['name'],
                    "Key": projectData['key'],
                    "Name": projectData['name'],
                }
            }
            newRecordArray.push(newRecord)
        }
        
    }
    while (newRecordArray.length > 0) {
        await table.createRecordsAsync(newRecordArray.slice(0,50));
        newRecordArray = newRecordArray.slice(50)
    }
    while (updateRecArray.length > 0) {
        await table.updateRecordsAsync(updateRecArray.slice(0,50));
        updateRecArray = updateRecArray.slice(50)
    }
}

function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;
    
    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}

//getepicsPARTONE
let table = base.getTable('Projects')
let query = await table.selectRecordsAsync()

let projectKeyID = []

for (let rec of query.records) {
    let projectInfo = {
        "Project Key": rec.getCellValueAsString('Key'),
        "ProjectRecordID": rec.id
    }
    projectKeyID.push(projectInfo)
}

console.log(projectKeyID)
output.set('projectKeys', projectKeyID)

//getepicsPARTTWO
let table = base.getTable('Epics')
let query = await table.selectRecordsAsync()

let newRecordArray = []
let updateRecArray = []

let inputConfig = input.config();
let projectKey = inputConfig.projectKey
let projectRecordID = inputConfig.projectRecordID

let startAt = 0;
const maxResults = 100;


await getEpics();

async function getEpics() {
    const username = 'test@gmail.com';
    const apiToken = '12345';
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);
    const jqlQuery = `project="${projectKey}" AND issuetype="Epic"`; 

    // Loop to handle pagination
    while (true) {
        const url = `https://test.atlassian.net/rest/api/3/search?jql=${encodeURIComponent(jqlQuery)}&startAt=${startAt}&maxResults=${maxResults}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                "Authorization": `Basic ${base64Credentials}`,
                "Accept": "application/json"
            }
        });

        if (!response.ok) {
            console.error("Failed to fetch epics:", response.statusText);
            return;
        }

        const payloadData = await response.json();
        console.log(payloadData)
        console.log(`Fetched ${payloadData.issues.length} epics starting at ${startAt}`);
        
        for (let epicData of payloadData.issues) {
            let foundCheck = false;
            for (let rec of query.records) {
                if (rec.getCellValueAsString('Key') == epicData.key) {
                    foundCheck = true;
                    let updateRec = {
                        id: rec.id,
                        fields: {
                            "Epic Name": epicData.fields.summary,
                            "Summary": epicData.fields.summary,
                            "Project": [{id: projectRecordID}],
                            "Key": epicData.key,
                            "Status": epicData.fields.status?.['name'] || '',
                        }
                    };
                    updateRecArray.push(updateRec);
                    break;
                }
            }

            if (!foundCheck) {
                let newRecord = {
                    fields: {
                        "Epic Name": epicData.fields.summary,
                        "Summary": epicData.fields.summary,
                        "Project": [{id: projectRecordID}],
                        "Key": epicData.key,
                        "Status": epicData.fields.status?.['name'] || '',
                    }
                };
                newRecordArray.push(newRecord);
            }
        }

        // Check if there are more issues to fetch
        if (payloadData.issues.length < maxResults) {
            break; // No more issues to fetch, exit the loop
        }

        // Otherwise, move to the next set of results (pagination)
        startAt += maxResults;
    }

    // Create new records in batches
    while (newRecordArray.length > 0) {
        await table.createRecordsAsync(newRecordArray.slice(0, 50));
        newRecordArray = newRecordArray.slice(50);
    }

    // Update existing records in batches
    while (updateRecArray.length > 0) {
        await table.updateRecordsAsync(updateRecArray.slice(0, 50));
        updateRecArray = updateRecArray.slice(50);
    }
}


function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;
    
    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}


//getSprintsPARTONE
let boardArray = []

await getBoards();

async function getBoards() {
    const username = 'test@gmail.com';
    const apiToken = '12345';
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);
    let startAt = 0;
    const maxResults = 50;  // Adjust the number of results per page if needed

    while (true) {
        const url = `https://test.atlassian.net/rest/agile/1.0/board?startAt=${startAt}&maxResults=${maxResults}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                "Authorization": `Basic ${base64Credentials}`,
                "Accept": "application/json"
            }
        });

        if (!response.ok) {
            console.error("Failed to fetch boards:", response.statusText);
            return;
        }

        const payloadData = await response.json();
        console.log(payloadData);

        // Process the boards data here (for example, you can log the board names or process further)
        payloadData.values.forEach(board => {
            boardArray.push(board.id);
        });

        // If the number of boards returned is less than maxResults, we know we've reached the last page
        if (payloadData.values.length < maxResults) {
            break;
        }

        // Otherwise, increment startAt for the next page
        startAt += maxResults;
    }
}

console.log(boardArray)

output.set("Boards", boardArray)

function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;
    
    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}

//getSprintsPARTTWO
let inputConfig = input.config();
let boardID = inputConfig.boardID;
//let boardID = 266

let table = base.getTable('Sprints')
let query = await table.selectRecordsAsync()

console.log(boardID)

let updateRecArray = []
let newRecordArray  = []

await getFieldNameFromId(table, "fld2RPe2bnSnHXuUB")
await getSprints(boardID)

async function getSprints(boardId) {
    const username = 'test@gmail.com';
    const apiToken = '12345';
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);

    let startAt = 0;
    const maxResults = 50;  // Number of results per page (adjustable)

    // Loop to handle pagination
    while (true) {
        const url = `https://test.atlassian.net/rest/agile/1.0/board/${boardId}/sprint?startAt=${startAt}&maxResults=${maxResults}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                "Authorization": `Basic ${base64Credentials}`,
                "Accept": "application/json"
            }
        });

        if (!response.ok) {
            console.error("Failed to fetch sprints:", response.statusText);
            return;
        }

        const payloadData = await response.json();
        console.log(`Fetched ${payloadData.values.length} sprints starting at ${startAt}`);
        console.log(payloadData)
        
        for (let sprintData of payloadData.values) {
            let foundCheck = false;
            for (let rec of query.records) {
                if (rec.getCellValueAsString('Sprint ID') == sprintData.id) {
                    foundCheck = true;
                    let updateRec = {
                        id: rec.id,
                        fields: {
                            "Sprint Name": sprintData.name,
                            "State": sprintData.state,
                            "Start Date": sprintData.startDate,
                            "End Date": sprintData.endDate,
                            "Sprint ID": (sprintData.id).toString()
                        }
                    };
                    updateRecArray.push(updateRec);
                    break;
                }
            }

            if (!foundCheck) {
                let newRecord = {
                    fields: {
                        "Sprint Name": sprintData.name,
                        "State": sprintData.state,
                        "Start Date": sprintData.startDate,
                        "End Date": sprintData.endDate,
                        "Sprint ID": (sprintData.id).toString()
                    }
                };
                newRecordArray.push(newRecord);
            }
        }

        // Check if there are more sprints to fetch
        if (payloadData.values.length < maxResults) {
            break; // No more sprints to fetch, exit the loop
        }

        // Otherwise, move to the next set of results (pagination)
        startAt += maxResults;
    }

    // Create new records in batches
    while (newRecordArray.length > 0) {
        await table.createRecordsAsync(newRecordArray.slice(0, 50));
        newRecordArray = newRecordArray.slice(50);
    }

    // Update existing records in batches
    while (updateRecArray.length > 0) {
        await table.updateRecordsAsync(updateRecArray.slice(0, 50));
        updateRecArray = updateRecArray.slice(50);
    }
}
function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;
    
    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}
async function getFieldNameFromId(table, fieldId) {
    const field = table.fields.find(f => f.id === fieldId);
    if (field) {
        console.log(field.name);
    } else {
        throw new Error("Field with this ID not found.");
    }
}


//getISSUESPARTONE
let table = base.getTable('Epics')
let query = await table.selectRecordsAsync()

let epicArray = []

for (let rec of query.records) {
    let epicInfo = {
        "Epic Key": rec.getCellValueAsString('Key'),
        "EpicRecordID": rec.id
    }
    epicArray.push(epicInfo)
}

console.log(epicArray)
output.set('epicKeys', epicArray)

//getIssuesPARTTWO
let table = base.getTable('Work/Tasks')
let query = await table.selectRecordsAsync()

let sprintsTable = base.getTable('Sprints')
let sprintsQuery = await sprintsTable.selectRecordsAsync()

let teamTable = base.getTable('Team Members');  
let teamQuery = await teamTable.selectRecordsAsync();

let epicTable = base.getTable('Epics');  
let epicQuery = await epicTable.selectRecordsAsync();

let projectTable = base.getTable('Projects');  // Assuming your Airtable table name is 'Team Members'
let projectQuery = await projectTable.selectRecordsAsync();

let newRecordArray = []
let updateRecArray = []

let inputConfig = input.config();
let epicKey = inputConfig.epicKey
//let epicKey = "ILAR-517"
let epicRecordID = inputConfig.epicRecordID

let startAt = 0;
const maxResults = 100;

//await getFieldNameFromId(table, "fldMKr80X0Y1VtYkO")
await getIssues();

async function getIssues() {
    const username = 'test@gmail.com';
    const apiToken = '12345';
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);
    const jqlQuery = `parent="${epicKey}"`; 

    console.log(jqlQuery)

    // Loop to handle pagination
    while (true) {
        const url = `https://test.atlassian.net/rest/api/3/search?jql=${encodeURIComponent(jqlQuery)}&startAt=${startAt}&maxResults=${maxResults}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                "Authorization": `Basic ${base64Credentials}`,
                "Accept": "application/json"
            }
        });

        if (!response.ok) {
            console.error("Failed to fetch issues:", response.statusText);
            return;
        }

        const payloadData = await response.json();
        console.log(payloadData)
        console.log(`Fetched ${payloadData.issues.length} issues starting at ${startAt}`);
        
        for (let issueData of payloadData.issues) {
            let foundCheck = false;
            for (let rec of query.records) {
                if (rec.getCellValueAsString('Key') == issueData.key) {
                    foundCheck = true;
                    let updateRec = {
                        id: rec.id,
                        fields: {
                        "Ticket Title": issueData['fields']['summary'] || '',
                        "Type": issueData['fields']['issuetype']?.['name'] || '',
                        "Key": issueData['key'] || '',
                        "Priority": issueData['fields']['priority']?.['name'] || '',
                        "Labels": (issueData['fields']['labels'] && issueData['fields']['labels'].length > 0) ? issueData['fields']['labels'].join(',') : '',
                        "Status": issueData['fields']['status']?.['name'] || '',
                        "Due Date": issueData['fields']['duedate'] || '',
                        "Done Date": issueData['fields']['resolutiondate'] || '',
                        "Created Date": issueData['fields']['created'] || '',
                        "Reporter": issueData['fields']['reporter']?.['displayName'] || '',
                        "Assignee": await getAssigneeRecordIDs(issueData['fields']['assignee']?.['accountId']) || [],
                        "Assignee Text": issueData['fields']['assignee']?.['displayName'] || '',
                        "Sprint List": await getSprintRecordIDs(issueData['fields']['customfield_10020']),
                        "SP": Number.isInteger(issueData['fields']['customfield_10026']) ? issueData['fields']['customfield_10026'] : null,
                        "Epic": await getEpicRecordIDs(issueData['fields']['parent']?.['key']) || []
                    }
                    };
                    updateRecArray.push(updateRec);
                    break;
                }
            }

            if (!foundCheck) {
                let newRecord = {
                    fields: {
                        "Ticket Title": issueData['fields']['summary'] || '',
                        "Type": issueData['fields']['issuetype']?.['name'] || '',
                        "Key": issueData['key'] || '',
                        "Priority": issueData['fields']['priority']?.['name'] || '',
                        "Labels": (issueData['fields']['labels'] && issueData['fields']['labels'].length > 0) ? issueData['fields']['labels'].join(',') : '',
                        "Status": issueData['fields']['status']?.['name'] || '',
                        "Due Date": issueData['fields']['duedate'] || '',
                        "Done Date": issueData['fields']['resolutiondate'] || '',
                        "Created Date": issueData['fields']['created'] || '',
                        "Reporter": issueData['fields']['reporter']?.['displayName'] || '',
                        "Assignee": await getAssigneeRecordIDs(issueData['fields']['assignee']?.['accountId']) || [],
                        "Assignee Text": issueData['fields']['assignee']?.['displayName'] || '',
                        "Sprint List": await getSprintRecordIDs(issueData['fields']['customfield_10020']),
                        "SP": Number.isInteger(issueData['fields']['customfield_10026']) ? issueData['fields']['customfield_10026'] : null,
                        "Epic": await getEpicRecordIDs(issueData['fields']['parent']?.['key']) || []
                    }
                };
                newRecordArray.push(newRecord);
            }
        }

        // Check if there are more issues to fetch
        if (payloadData.issues.length < maxResults) {
            break; // No more issues to fetch, exit the loop
        }

        // Otherwise, move to the next set of results (pagination)
        startAt += maxResults;
    }

    //Create new records in batches
    while (newRecordArray.length > 0) {
        await table.createRecordsAsync(newRecordArray.slice(0, 50));
        newRecordArray = newRecordArray.slice(50);
    }

    // Update existing records in batches
    while (updateRecArray.length > 0) {
        await table.updateRecordsAsync(updateRecArray.slice(0, 50));
        updateRecArray = updateRecArray.slice(50);
    }
}


function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;
    
    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}
async function getFieldNameFromId(table, fieldId) {
    const field = table.fields.find(f => f.id === fieldId);
    if (field) {
        console.log(field.name);
    } else {
        throw new Error("Field with this ID not found.");
    }
}
async function getSprintRecordIDs(sprints) {
    const sprintRecordIDs = [];

    //console.log(sprints)

    if(sprints == null){
        return []
    }

    // Loop through each sprint object
    for (let sprint of sprints) {
        const sprintID = sprint.id;
        
        // Loop through the query records and match Sprint ID
        for (let rec of sprintsQuery.records) {
            if (rec.getCellValueAsString('Sprint ID') === sprintID.toString()) { // Assuming 'Sprint ID' is the field containing the sprint ID in Airtable
                sprintRecordIDs.push({ id: rec.id });
                //console.log('found')
            }
        }
    }

    return sprintRecordIDs;
}
async function getAssigneeRecordIDs(assigneeID) {

    
    const assigneeRecordIDs = [];

    // Check if the provided assigneeID is valid
    if (assigneeID == null) {
        return assigneeRecordIDs;
    }

    // Loop through the records in the 'Team Members' table and match Assignee ID
    for (let rec of teamQuery.records) {
        if (rec.getCellValueAsString('Jira ID') === assigneeID.toString()) {  // Assuming 'Jira ID' is the field containing the Assignee's Jira ID in Airtable
            assigneeRecordIDs.push({ id: rec.id });
        }
    }

    //console.log(assigneeRecordIDs)

    return assigneeRecordIDs;  // Return array of matching record IDs
}

async function getEpicRecordIDs(epicKey) {
    
    const epicRecordIDs = [];

    // Check if the provided epicKey is valid
    if (epicKey == null) {
        return epicRecordIDs;
    }

    // Loop through the records in the relevant table and match Epic Key
    for (let rec of epicQuery.records) {
        if (rec.getCellValueAsString('Key') === epicKey.toString()) {  // Assuming 'Epic Key' is the field containing the Epic Key in Airtable
            epicRecordIDs.push({ id: rec.id });
        }
    }

    // Return array of matching record IDs
    return epicRecordIDs;
}
async function getProjectRecordIDs(projectKey) {
    
    const projectRecordIDs = [];

    // Check if the provided projectKey is valid
    if (projectKey == null) {
        return projectRecordIDs;
    }

    // Loop through the records in the 'Project' table and match Project Key
    for (let rec of projectQuery.records) {
        if (rec.getCellValueAsString('Project Key').includes(projectKey.toString())) {  // Assuming 'Project Key' is the field containing the Project Key in Airtable
            projectRecordIDs.push({ id: rec.id });
        }
    }

    // Return array of matching record IDs
    return projectRecordIDs;
}

//getISSUESWITHOUTEPICPARTONE
const totalTickets = 30000;  
const rangeStep = 200;  

function generateTicketRanges(totalTickets, rangeStep) {
    const ranges = [];
    
    for (let startRange = 0; startRange < totalTickets; startRange += rangeStep) {
        const endRange = Math.min(startRange + rangeStep - 1, totalTickets - 1);
        ranges.push({ 
            "startRange":startRange, 
            "endRange": endRange });
    }

    return ranges;
}

const ticketRanges = generateTicketRanges(totalTickets, rangeStep);

console.log(ticketRanges);

output.set('ranges',ticketRanges)

//getISSUESWITHOUTEPICPARTTWO

let table = base.getTable('Work/Tasks')
let query = await table.selectRecordsAsync()

let sprintsTable = base.getTable('Sprints')
let sprintsQuery = await sprintsTable.selectRecordsAsync()

let teamTable = base.getTable('Team Members');  // Assuming your Airtable table name is 'Team Members'
let teamQuery = await teamTable.selectRecordsAsync();

let epicTable = base.getTable('Epics');  // Assuming your Airtable table name is 'Team Members'
let epicQuery = await epicTable.selectRecordsAsync();

let newRecordArray = []
let updateRecArray = []

let inputConfig = input.config();

let startRange = inputConfig.startRange
let endRange = inputConfig.endRange


//await getFieldNameFromId(table, "fldmyDHyRPtq3vQ9t")
//console.log('test')
await getIssues();

async function getIssues() {
    const username = 'test@gmail.com';
    const apiToken = '12345';
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);
    const jqlQuery = `issuetype != "Epic" AND "Parent" IS EMPTY`; 

    console.log(jqlQuery)

    // Loop to handle pagination
    const maxResults = 100; // The maximum results per request (Jira's limit is 100)
    let startAt = startRange; // Starting point for pagination
    const totalResults = endRange; // The number of issues to fetch (3000)

    while (startAt < totalResults) {
        const url = `https://test.atlassian.net/rest/api/3/search?jql=${encodeURIComponent(jqlQuery)}&startAt=${startAt}&maxResults=${maxResults}&expand=schema,names`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                "Authorization": `Basic ${base64Credentials}`,
                "Accept": "application/json"
            }
        });

        if (!response.ok) {
            console.error("Failed to fetch issues:", response.statusText);
            return;
        }

        const payloadData = await response.json();
        //console.log(payloadData);
        console.log(`Fetched ${payloadData.issues.length} issues starting at ${startAt}`);

        for (let issueData of payloadData.issues) {
            let foundCheck = false;
            for (let rec of query.records) {
                if (rec.getCellValueAsString('Key') == issueData.key) {
                    foundCheck = true;
                    let updateRec = {
                        id: rec.id,
                        fields: {
                        "Ticket Title": issueData['fields']['summary'] || '',
                        "Type": issueData['fields']['issuetype']?.['name'] || '',
                        "Key": issueData['key'] || '',
                        "Priority": issueData['fields']['priority']?.['name'] || '',
                        "Labels": (issueData['fields']['labels'] && issueData['fields']['labels'].length > 0) ? issueData['fields']['labels'].join(',') : '',
                        "Status": issueData['fields']['status']?.['name'] || '',
                        "Due Date": issueData['fields']['duedate'] || '',
                        "Done Date": issueData['fields']['resolutiondate'] || '',
                        "Created Date": issueData['fields']['created'] || '',
                        "Reporter": issueData['fields']['reporter']?.['displayName'] || '',
                        "Assignee": await getAssigneeRecordIDs(issueData['fields']['assignee']?.['accountId']) || [],
                        "Assignee Text": issueData['fields']['assignee']?.['displayName'] || '',
                        "Sprint List": await getSprintRecordIDs(issueData['fields']['customfield_10020']),
                        "SP": Number.isInteger(issueData['fields']['customfield_10026']) ? issueData['fields']['customfield_10026'] : null,
                        "Epic": await getEpicRecordIDs(issueData['fields']['parent']?.['key']) || []
                    }
                    };
                    updateRecArray.push(updateRec);
                    break;
                }
            }

            if (!foundCheck) {
                let newRecord = {
                    fields: {
                        "Ticket Title": issueData['fields']['summary'] || '',
                        "Type": issueData['fields']['issuetype']?.['name'] || '',
                        "Key": issueData['key'] || '',
                        "Priority": issueData['fields']['priority']?.['name'] || '',
                        "Labels": (issueData['fields']['labels'] && issueData['fields']['labels'].length > 0) ? issueData['fields']['labels'].join(',') : '',
                        "Status": issueData['fields']['status']?.['name'] || '',
                        "Due Date": issueData['fields']['duedate'] || '',
                        "Done Date": issueData['fields']['resolutiondate'] || '',
                        "Created Date": issueData['fields']['created'] || '',
                        "Reporter": issueData['fields']['reporter']?.['displayName'] || '',
                        "Assignee": await getAssigneeRecordIDs(issueData['fields']['assignee']?.['accountId']) || [],
                        "Assignee Text": issueData['fields']['assignee']?.['displayName'] || '',
                        "Sprint List": await getSprintRecordIDs(issueData['fields']['customfield_10020']),
                        "SP": Number.isInteger(issueData['fields']['customfield_10026']) ? issueData['fields']['customfield_10026'] : null,
                        "Epic": await getEpicRecordIDs(issueData['fields']['parent']?.['key']) || []
                    }
                };
                newRecordArray.push(newRecord);
            }
        }

        // Check if we've reached the limit of 3000 issues
        if (startAt + maxResults >= totalResults) {
            break; // Stop fetching once we hit 3000 issues
        }

        // Otherwise, move to the next set of results (pagination)
        startAt += maxResults;
    }

    //Create new records in batches
    while (newRecordArray.length > 0) {
        await table.createRecordsAsync(newRecordArray.slice(0, 50));
        newRecordArray = newRecordArray.slice(50);
    }

    // Update existing records in batches
    while (updateRecArray.length > 0) {
        await table.updateRecordsAsync(updateRecArray.slice(0, 50));
        updateRecArray = updateRecArray.slice(50);
    }
}


function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;
    
    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}
async function getFieldNameFromId(table, fieldId) {
    const field = table.fields.find(f => f.id === fieldId);
    if (field) {
        console.log(field.name);
    } else {
        throw new Error("Field with this ID not found.");
    }
}
async function getSprintRecordIDs(sprints) {
    const sprintRecordIDs = [];

    //console.log(sprints)

    if(sprints == null){
        return []
    }

    // Loop through each sprint object
    for (let sprint of sprints) {
        const sprintID = sprint.id;
        
        // Loop through the query records and match Sprint ID
        for (let rec of sprintsQuery.records) {
            if (rec.getCellValueAsString('Sprint ID') === sprintID.toString()) { // Assuming 'Sprint ID' is the field containing the sprint ID in Airtable
                sprintRecordIDs.push({ id: rec.id });
                //console.log('found')
            }
        }
    }

    return sprintRecordIDs;
}
async function getAssigneeRecordIDs(assigneeID) {

    
    const assigneeRecordIDs = [];

    // Check if the provided assigneeID is valid
    if (assigneeID == null) {
        return assigneeRecordIDs;
    }

    // Loop through the records in the 'Team Members' table and match Assignee ID
    for (let rec of teamQuery.records) {
        if (rec.getCellValueAsString('Jira ID') === assigneeID.toString()) {  // Assuming 'Jira ID' is the field containing the Assignee's Jira ID in Airtable
            assigneeRecordIDs.push({ id: rec.id });
        }
    }

    //console.log(assigneeRecordIDs)

    return assigneeRecordIDs;  // Return array of matching record IDs
}
async function getEpicRecordIDs(epicKey) {
    
    const epicRecordIDs = [];

    // Check if the provided epicKey is valid
    if (epicKey == null) {
        return epicRecordIDs;
    }
    // Loop through the records in the relevant table and match Epic Key
    for (let rec of epicQuery.records) {
        if (rec.getCellValueAsString('Key') === epicKey.toString()) {  // Assuming 'Epic Key' is the field containing the Epic Key in Airtable
            epicRecordIDs.push({ id: rec.id });
        }
    }
    // Return array of matching record IDs
    return epicRecordIDs;
}

//getlatestissuesPARTONE
let table = base.getTable('Epics')
let query = await table.selectRecordsAsync()

let newRecordArray = []
let updateRecArray = []

let inputConfig = input.config();

let startAt = 0;
const maxResults = 100;


await getEpics();

async function getEpics() {
    const username = 'test@gmail.com';
    const apiToken = '12345';
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);
    const jqlQuery = `issuetype="Epic"`; 

    // Loop to handle pagination
    while (true) {
        const url = `https://test.atlassian.net/rest/api/3/search?jql=${encodeURIComponent(jqlQuery)}&startAt=${startAt}&maxResults=${maxResults}`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                "Authorization": `Basic ${base64Credentials}`,
                "Accept": "application/json"
            }
        });

        if (!response.ok) {
            console.error("Failed to fetch epics:", response.statusText);
            return;
        }

        const payloadData = await response.json();
        console.log(payloadData)
        console.log(`Fetched ${payloadData.issues.length} epics starting at ${startAt}`);
        
        for (let epicData of payloadData.issues) {
            let foundCheck = false;
            for (let rec of query.records) {
                if (rec.getCellValueAsString('Key') == epicData.key) {
                    foundCheck = true;
                    let updateRec = {
                        id: rec.id,
                        fields: {
                            "Epic Name": epicData.fields.summary,
                            "Summary": epicData.fields.summary,
                            "Key": epicData.key,
                            "Status": epicData.fields.status?.['name'] || '',
                        }
                    };
                    updateRecArray.push(updateRec);
                    break;
                }
            }

            if (!foundCheck) {
                let newRecord = {
                    fields: {
                        "Epic Name": epicData.fields.summary,
                        "Summary": epicData.fields.summary,
                        "Key": epicData.key,
                        "Status": epicData.fields.status?.['name'] || '',
                    }
                };
                newRecordArray.push(newRecord);
            }
        }

        // Check if there are more issues to fetch
        if (payloadData.issues.length < maxResults) {
            break; // No more issues to fetch, exit the loop
        }

        // Otherwise, move to the next set of results (pagination)
        startAt += maxResults;
    }

    // Create new records in batches
    while (newRecordArray.length > 0) {
        await table.createRecordsAsync(newRecordArray.slice(0, 50));
        newRecordArray = newRecordArray.slice(50);
    }

    // Update existing records in batches
    while (updateRecArray.length > 0) {
        await table.updateRecordsAsync(updateRecArray.slice(0, 50));
        updateRecArray = updateRecArray.slice(50);
    }
}


function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;
    
    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}

//getlatestissuesPARTTWO
const totalTickets = 200;  
const rangeStep = 100;  

let teamTable = base.getTable('Team Members');  // Assuming your Airtable table name is 'Team Members'
let teamQuery = await teamTable.selectRecordsAsync();

let epicTable = base.getTable('Epics');  // Assuming your Airtable table name is 'Team Members'
let epicQuery = await epicTable.selectRecordsAsync();

// Function to generate ticket ranges
function generateTicketRanges(totalTickets, rangeStep) {
    const ranges = [];
    for (let startRange = 0; startRange < totalTickets; startRange += rangeStep) {
        const endRange = Math.min(startRange + rangeStep - 1, totalTickets - 1);
        ranges.push({ 
            "startRange": startRange, 
            "endRange": endRange 
        });
    }

    return ranges;
}

const ticketRanges = generateTicketRanges(totalTickets, rangeStep);

// Set up Airtable tables
let table = base.getTable('Work/Tasks');
let query = await table.selectRecordsAsync();

let sprintsTable = base.getTable('Sprints');
let sprintsQuery = await sprintsTable.selectRecordsAsync();

// Arrays to collect new and update records
let newRecordArray = [];
let updateRecArray = [];

// JQL Query for the last 200 created issues
const maxResults = 200; // Max number of results per request (Jira's limit)

//await getFieldNameFromId(table, "fldxIt6k6HV6WM19O");

// Process each ticket range
for (let range of ticketRanges) {
    let startRange = range.startRange;
    let endRange = range.endRange;

    //console.log(startRange)

    

    await getIssues(startRange, endRange);
}

// Function to fetch issues from Jira
async function getIssues(startRange, endRange) {
    const username = 'test@gmail.com';
    const apiToken = '12345';
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);
    const jqlQueryUpdated = `issuetype != Epic ORDER BY created`;

    // Loop to handle pagination
    let startAt = startRange; // Starting point for pagination
    const totalResults = endRange; // The number of issues to fetch (range from Airtable)

    while (startAt < totalResults) {
        const url = `https://test.atlassian.net/rest/api/3/search?jql=${encodeURIComponent(jqlQueryUpdated)}&startAt=${startAt}&maxResults=${maxResults}&expand=schema,names`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                "Authorization": `Basic ${base64Credentials}`,
                "Accept": "application/json"
            }
        });

        if (!response.ok) {
            console.error("Failed to fetch issues:", response.statusText);
            return;
        }

        const payloadData = await response.json();
        console.log(payloadData);

        // Process fetched issues
        for (let issueData of payloadData.issues) {
            let foundCheck = false;
            for (let rec of query.records) {
                if (rec.getCellValueAsString('Key') == issueData.key) {
                    foundCheck = true;
                    let updateRec = {
                        id: rec.id,
                        fields: {
                            "Ticket Title": issueData['fields']['summary'] || '',
                            "Type": issueData['fields']['issuetype']?.['name'] || '',
                            "Key": issueData['key'] || '',
                            "Priority": issueData['fields']['priority']?.['name'] || '',
                            "Labels": (issueData['fields']['labels'] && issueData['fields']['labels'].length > 0) ? issueData['fields']['labels'].join(',') : '',
                            "Status": issueData['fields']['status']?.['name'] || '',
                            "Due Date": issueData['fields']['duedate'] || '',
                            "Done Date": issueData['fields']['resolutiondate'] || '',
                            "Created Date": issueData['fields']['created'] || '',
                            "Reporter": issueData['fields']['reporter']?.['displayName'] || '',
                            "Assignee": await getAssigneeRecordIDs(issueData['fields']['assignee']?.['accountId']) || [],
                            "Assignee Text": issueData['fields']['assignee']?.['displayName'] || '',
                            "Sprint List": await getSprintRecordIDs(issueData['fields']['customfield_10020']),
                            "SP": Number.isInteger(issueData['fields']['customfield_10026']) ? issueData['fields']['customfield_10026'] : null,
                            "Epic": await getEpicRecordIDs(issueData['fields']['parent']?.['key']) || []
                        }
                    };
                    updateRecArray.push(updateRec);
                    break;
                }
            }

            if (!foundCheck) {
                let newRecord = {
                    fields: {
                        "Ticket Title": issueData['fields']['summary'] || '',
                        "Type": issueData['fields']['issuetype']?.['name'] || '',
                        "Key": issueData['key'] || '',
                        "Priority": issueData['fields']['priority']?.['name'] || '',
                        "Labels": (issueData['fields']['labels'] && issueData['fields']['labels'].length > 0) ? issueData['fields']['labels'].join(',') : '',
                        "Status": issueData['fields']['status']?.['name'] || '',
                        "Due Date": issueData['fields']['duedate'] || '',
                        "Done Date": issueData['fields']['resolutiondate'] || '',
                        "Created Date": issueData['fields']['created'] || '',
                        "Reporter": issueData['fields']['reporter']?.['displayName'] || '',
                        "Assignee": await getAssigneeRecordIDs(issueData['fields']['assignee']?.['accountId']) || [],
                        "Assignee Text": issueData['fields']['assignee']?.['displayName'] || '',
                        "Sprint List": await getSprintRecordIDs(issueData['fields']['customfield_10020']),
                        "SP": Number.isInteger(issueData['fields']['customfield_10026']) ? issueData['fields']['customfield_10026'] : null,
                        "Epic": await getEpicRecordIDs(issueData['fields']['parent']?.['key']) || []
                    }
                };
                newRecordArray.push(newRecord);
            }
        }

        // Check if we've reached the limit of totalResults
        if (startAt + maxResults >= totalResults) {
            break;
        }

        // Otherwise, move to the next set of results (pagination)
        startAt += maxResults;
    }

    //console.log(updateRecArray)
    //console.log(newRecordArray)

    // Create new records in batches
    while (newRecordArray.length > 0) {
        await table.createRecordsAsync(newRecordArray.slice(0, 50));
        newRecordArray = newRecordArray.slice(50);
    }

    // Update existing records in batches
    while (updateRecArray.length > 0) {
        await table.updateRecordsAsync(updateRecArray.slice(0, 50));
        updateRecArray = updateRecArray.slice(50);
    }
}

// Function to handle base64 encoding for authentication
function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;

    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}

// Function to get field name from ID
async function getFieldNameFromId(table, fieldId) {
    const field = table.fields.find(f => f.id === fieldId);
    if (field) {
        console.log(field.name);
    } else {
        throw new Error("Field with this ID not found.");
    }
}

// Function to get sprint record IDs
async function getSprintRecordIDs(sprints) {
    const sprintRecordIDs = [];

    if (sprints == null) {
        return [];
    }

    for (let sprint of sprints) {
        const sprintID = sprint.id;

        for (let rec of sprintsQuery.records) {
            if (rec.getCellValueAsString('Sprint ID') === sprintID.toString()) {
                sprintRecordIDs.push({ id: rec.id });
            }
        }
    }

    return sprintRecordIDs;
}
async function getAssigneeRecordIDs(assigneeID) {

    
    const assigneeRecordIDs = [];

    // Check if the provided assigneeID is valid
    if (assigneeID == null) {
        return assigneeRecordIDs;
    }

    // Loop through the records in the 'Team Members' table and match Assignee ID
    for (let rec of teamQuery.records) {
        if (rec.getCellValueAsString('Jira ID') === assigneeID.toString()) {  // Assuming 'Jira ID' is the field containing the Assignee's Jira ID in Airtable
            assigneeRecordIDs.push({ id: rec.id });
        }
    }

    //console.log(assigneeRecordIDs)

    return assigneeRecordIDs;  // Return array of matching record IDs
}
async function getEpicRecordIDs(epicKey) {
    
    const epicRecordIDs = [];

    // Check if the provided epicKey is valid
    if (epicKey == null) {
        return epicRecordIDs;
    }
    // Loop through the records in the relevant table and match Epic Key
    for (let rec of epicQuery.records) {
        if (rec.getCellValueAsString('Key') === epicKey.toString()) {  // Assuming 'Epic Key' is the field containing the Epic Key in Airtable
            epicRecordIDs.push({ id: rec.id });
        }
    }
    // Return array of matching record IDs
    return epicRecordIDs;
}

//getlatestissuesPARTTHREE

const totalTickets = 200;  
const rangeStep = 100;  

let teamTable = base.getTable('Team Members');  
let teamQuery = await teamTable.selectRecordsAsync();

let epicTable = base.getTable('Epics');  
let epicQuery = await epicTable.selectRecordsAsync();

let projectTable = base.getTable('Projects');  // Assuming your Airtable table name is 'Team Members'
let projectQuery = await projectTable.selectRecordsAsync();


// Function to generate ticket ranges
function generateTicketRanges(totalTickets, rangeStep) {
    const ranges = [];
    for (let startRange = 0; startRange < totalTickets; startRange += rangeStep) {
        const endRange = Math.min(startRange + rangeStep - 1, totalTickets - 1);
        ranges.push({ 
            "startRange": startRange, 
            "endRange": endRange 
        });
    }

    return ranges;
}

const ticketRanges = generateTicketRanges(totalTickets, rangeStep);

// Set up Airtable tables
let table = base.getTable('Work/Tasks');
let query = await table.selectRecordsAsync();

let sprintsTable = base.getTable('Sprints');
let sprintsQuery = await sprintsTable.selectRecordsAsync();

// Arrays to collect new and update records
let newRecordArray = [];
let updateRecArray = [];

// JQL Query for the last 200 created issues
const maxResults = 200; // Max number of results per request (Jira's limit)

// Process each ticket range
for (let range of ticketRanges) {
    let startRange = range.startRange;
    let endRange = range.endRange;

    //console.log(startRange)

    await getFieldNameFromId(table, "fldJ64jlRgRREhE2o");

    await getIssues(startRange, endRange);
}

// Function to fetch issues from Jira
async function getIssues(startRange, endRange) {
    const username = 'test@gmail.com';
    const apiToken = '12345';
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);
    const jqlQueryUpdated = `issuetype != Epic ORDER BY updated`;

    // Loop to handle pagination
    let startAt = startRange; // Starting point for pagination
    const totalResults = endRange; // The number of issues to fetch (range from Airtable)

    while (startAt < totalResults) {
        const url = `https://test.atlassian.net/rest/api/3/search?jql=${encodeURIComponent(jqlQueryUpdated)}&startAt=${startAt}&maxResults=${maxResults}&expand=schema,names`;

        const response = await fetch(url, {
            method: 'GET',
            headers: {
                "Authorization": `Basic ${base64Credentials}`,
                "Accept": "application/json"
            }
        });

        if (!response.ok) {
            console.error("Failed to fetch issues:", response.statusText);
            return;
        }

        const payloadData = await response.json();
        console.log(`Fetched ${payloadData.issues.length} created issues starting at ${startAt}`);

        // Process fetched issues
        for (let issueData of payloadData.issues) {
            let foundCheck = false;
            for (let rec of query.records) {
                if (rec.getCellValueAsString('Key') == issueData.key) {
                    foundCheck = true;
                    let updateRec = {
                        id: rec.id,
                        fields: {
                        "Ticket Title": issueData['fields']['summary'] || '',
                        "Type": issueData['fields']['issuetype']?.['name'] || '',
                        "Key": issueData['key'] || '',
                        "Priority": issueData['fields']['priority']?.['name'] || '',
                        "Labels": (issueData['fields']['labels'] && issueData['fields']['labels'].length > 0) ? issueData['fields']['labels'].join(',') : '',
                        "Status": issueData['fields']['status']?.['name'] || '',
                        "Due Date": issueData['fields']['duedate'] || '',
                        "Done Date": issueData['fields']['resolutiondate'] || '',
                        "Created Date": issueData['fields']['created'] || '',
                        "Reporter": issueData['fields']['reporter']?.['displayName'] || '',
                        "Assignee": await getAssigneeRecordIDs(issueData['fields']['assignee']?.['accountId']) || [],
                        "Assignee Text": issueData['fields']['assignee']?.['displayName'] || '',
                        "Sprint List": await getSprintRecordIDs(issueData['fields']['customfield_10020']),
                        "SP": Number.isInteger(issueData['fields']['customfield_10026']) ? issueData['fields']['customfield_10026'] : null,
                        "Epic": await getEpicRecordIDs(issueData['fields']['parent']?.['key']) || []
                    }
                    };
                    updateRecArray.push(updateRec);
                    break;
                }
            }

            if (!foundCheck) {
                let newRecord = {
                    fields: {
                        "Ticket Title": issueData['fields']['summary'] || '',
                        "Type": issueData['fields']['issuetype']?.['name'] || '',
                        "Key": issueData['key'] || '',
                        "Priority": issueData['fields']['priority']?.['name'] || '',
                        "Labels": (issueData['fields']['labels'] && issueData['fields']['labels'].length > 0) ? issueData['fields']['labels'].join(',') : '',
                        "Status": issueData['fields']['status']?.['name'] || '',
                        "Due Date": issueData['fields']['duedate'] || '',
                        "Done Date": issueData['fields']['resolutiondate'] || '',
                        "Created Date": issueData['fields']['created'] || '',
                        "Reporter": issueData['fields']['reporter']?.['displayName'] || '',
                        "Assignee": await getAssigneeRecordIDs(issueData['fields']['assignee']?.['accountId']) || [],
                        "Assignee Text": issueData['fields']['assignee']?.['displayName'] || '',
                        "Sprint List": await getSprintRecordIDs(issueData['fields']['customfield_10020']),
                        "SP": Number.isInteger(issueData['fields']['customfield_10026']) ? issueData['fields']['customfield_10026'] : null,
                        "Epic": await getEpicRecordIDs(issueData['fields']['parent']?.['key']) || []
                    }
                };
                newRecordArray.push(newRecord);
            }
        }

        // Check if we've reached the limit of totalResults
        if (startAt + maxResults >= totalResults) {
            break;
        }

        // Otherwise, move to the next set of results (pagination)
        startAt += maxResults;
    }

    //console.log(updateRecArray)
    //console.log(newRecordArray)

    // Create new records in batches
    while (newRecordArray.length > 0) {
        await table.createRecordsAsync(newRecordArray.slice(0, 50));
        newRecordArray = newRecordArray.slice(50);
    }

    // Update existing records in batches
    while (updateRecArray.length > 0) {
        await table.updateRecordsAsync(updateRecArray.slice(0, 50));
        updateRecArray = updateRecArray.slice(50);
    }
}

// Function to handle base64 encoding for authentication
function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;

    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}

// Function to get field name from ID
async function getFieldNameFromId(table, fieldId) {
    const field = table.fields.find(f => f.id === fieldId);
    if (field) {
        console.log(field.name);
    } else {
        throw new Error("Field with this ID not found.");
    }
}

// Function to get sprint record IDs
async function getSprintRecordIDs(sprints) {
    const sprintRecordIDs = [];

    if (sprints == null) {
        return [];
    }

    for (let sprint of sprints) {
        const sprintID = sprint.id;

        for (let rec of sprintsQuery.records) {
            if (rec.getCellValueAsString('Sprint ID') === sprintID.toString()) {
                sprintRecordIDs.push({ id: rec.id });
            }
        }
    }

    return sprintRecordIDs;
}
async function getAssigneeRecordIDs(assigneeID) {

    
    const assigneeRecordIDs = [];

    // Check if the provided assigneeID is valid
    if (assigneeID == null) {
        return assigneeRecordIDs;
    }

    // Loop through the records in the 'Team Members' table and match Assignee ID
    for (let rec of teamQuery.records) {
        if (rec.getCellValueAsString('Jira ID') === assigneeID.toString()) {  // Assuming 'Jira ID' is the field containing the Assignee's Jira ID in Airtable
            assigneeRecordIDs.push({ id: rec.id });
        }
    }

    //console.log(assigneeRecordIDs)

    return assigneeRecordIDs;  // Return array of matching record IDs
}

async function getEpicRecordIDs(epicKey) {
    
    const epicRecordIDs = [];

    // Check if the provided epicKey is valid
    if (epicKey == null) {
        return epicRecordIDs;
    }

    // Loop through the records in the relevant table and match Epic Key
    for (let rec of epicQuery.records) {
        if (rec.getCellValueAsString('Key') === epicKey.toString()) {  // Assuming 'Epic Key' is the field containing the Epic Key in Airtable
            epicRecordIDs.push({ id: rec.id });
        }
    }

    // Return array of matching record IDs
    return epicRecordIDs;
}
async function getProjectRecordIDs(projectKey) {
    
    const projectRecordIDs = [];

    // Check if the provided projectKey is valid
    if (projectKey == null) {
        return projectRecordIDs;
    }

    // Loop through the records in the 'Project' table and match Project Key
    for (let rec of projectQuery.records) {
        if (rec.getCellValueAsString('Project Key').includes(projectKey.toString())) {  // Assuming 'Project Key' is the field containing the Project Key in Airtable
            projectRecordIDs.push({ id: rec.id });
        }
    }

    // Return array of matching record IDs
    return projectRecordIDs;
}

//getlatestissuesPARTFOUR
let worktable = base.getTable("Work/Tasks")
let workView = worktable.getView("Missing Project")
let workQuery = await workView.selectRecordsAsync()

let projectTable = base.getTable('Projects')
let projectQuery = await projectTable.selectRecordsAsync()

let updateRecArray = []

for (let workRec of workQuery.records) {
    for (let projectRec of projectQuery.records) {
        if (workRec.getCellValueAsString('Key').includes(projectRec.getCellValueAsString('Key'))) {
            let updateRec = {
                id: workRec.id,
                fields: {
                    "Project": [{id: projectRec.id}]
                }
            }
            updateRecArray.push(updateRec)
            break;
        }
    }
}

while (updateRecArray.length > 0) {
    await worktable.updateRecordsAsync(updateRecArray.slice(0, 50));
    updateRecArray = updateRecArray.slice(50);
}

//getlatestissuesPARTFIVE
let epictable = base.getTable("Epics")
let epicQuery = await epictable.selectRecordsAsync()

let projectTable = base.getTable('Projects')
let projectQuery = await projectTable.selectRecordsAsync()

let updateRecArray = []

for (let epicRec of epicQuery.records) {
    for (let projectRec of projectQuery.records) {
        if (epicRec.getCellValueAsString('Key').includes(projectRec.getCellValueAsString('Key'))) {
            let updateRec = {
                id: epicRec.id,
                fields: {
                    "Project": [{id: projectRec.id}]
                }
            }
            updateRecArray.push(updateRec)
            break;
        }
    }
}

while (updateRecArray.length > 0) {
    await epictable.updateRecordsAsync(updateRecArray.slice(0, 50));
    updateRecArray = updateRecArray.slice(50);
}
//getallusers
await fetchAllUsers()

async function fetchAllUsers() {
    const username = 'test@test.org';
    const apiToken = 'test12354';
 
    const base64Credentials = btoaCustom(`${username}:${apiToken}`);
    
    const url = 'https://air-org.atlassian.net/rest/api/3/users/search?startAt=0&maxResults=1000'; // You can adjust maxResults as needed

    const usertable = base.getTable('Team Members');  // Replace with your Airtable table name where users are stored
    const userquery = await usertable.selectRecordsAsync();

    let newUserArray = [];
    let updateUserArray = [];

    let startAt = 0; // Pagination starting point
    const urlWithPagination = url;

    const response = await fetch(urlWithPagination, {
        method: 'GET',
        headers: {
            "Authorization": `Basic ${base64Credentials}`,
            "Accept": "application/json"
        }
    });

    console.log(response)

    if (!response.ok) {
        console.error("Failed to fetch users:", response.statusText);
        return;
    }

    const usersData = await response.json();
    console.log(usersData)
    console.log(`Fetched ${usersData.length} users starting at ${startAt}`);

    // Process fetched users
    for (let userData of usersData) {
        let foundCheck = false;

        // Loop through Airtable records to find matching users
        for (let rec of userquery.records) {
            if (rec.getCellValueAsString('Jira ID') == userData.accountId) { // Match on user email or any unique identifier
                foundCheck = true;

                // Prepare update record
                let updateRec = {
                    id: rec.id,
                    fields: {
                        "Name": userData.displayName || '',
                        "Jira ID": userData.accountId || '',
                        "Active": userData.active || false
                    }
                };
                updateUserArray.push(updateRec);
                break;
            }
        }

        // If not found, create a new user record
        if (!foundCheck) {
            let newRecord = {
                fields: {
                    "Name": userData.displayName || '',
                    "Jira ID": userData.accountId || '',
                    "Active": userData.active || false
                }
            };
            newUserArray.push(newRecord);
        }
    }
    

    // Create new user records in batches
    while (newUserArray.length > 0) {
        await usertable.createRecordsAsync(newUserArray.slice(0, 50));
        newUserArray = newUserArray.slice(50);
    }

    // Update existing user records in batches
    while (updateUserArray.length > 0) {
        await usertable.updateRecordsAsync(updateUserArray.slice(0, 50));
        updateUserArray = updateUserArray.slice(50);

    }
}


// Base64 encoding function for authentication
function btoaCustom(input) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let str = '';
    let i = 0;

    // Convert each chunk of 3 bytes into 4 Base64 characters
    while (i < input.length) {
        const byte1 = input.charCodeAt(i++);
        const byte2 = input.charCodeAt(i++);
        const byte3 = input.charCodeAt(i++);
        
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        const enc4 = byte3 & 63;

        str += chars.charAt(enc1) + chars.charAt(enc2) + (isNaN(byte2) ? '=' : chars.charAt(enc3)) + (isNaN(byte3) ? '=' : chars.charAt(enc4));
    }

    return str;
}

// Call the function
fetchAllUsers();
